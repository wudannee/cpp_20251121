name: C++ Build and Release # 工作流名称

# 只有当推送了新的 Git Tag (标签)，且标签名以 'v' 开头时，才触发此工作流
on:
  push:
    tags:
      - 'v*' 

jobs:
  # ==================================
  # 任务 1: Build (编译)
  # ==================================
  build:
    # 使用矩阵策略，同时在不同的操作系统上运行
    strategy:
      matrix:
        os: [ubuntu-22.04, windows-latest]
        include: # 定义特定OS的输出文件名后缀
          - os: ubuntu-22.04
            suffix: "_linux_ubuntu-22.04"
            file_extension: ""
          - os: windows-latest
            suffix: "_windows"
            file_extension: ".exe"

    runs-on: ${{ matrix.os }} # 在矩阵定义的操作系统上运行

    steps:
      - name: Checkout code # 步骤 1: 获取代码
        uses: actions/checkout@v4

      # 步骤 2: 编译 C++ 代码
      - name: Compile C++ with G++
        id: compile_step # 给这个步骤一个ID，以便后续引用它的输出
        # FIX: 显式指定使用 Bash Shell，确保在 Windows 和 Linux 上语法一致
        shell: bash
        run: |
          # 1. 提取 g++ 的完整版本号 (例如 11.4.0)
          FULL_GCC_VERSION=$(g++ -dumpfullversion)
          # 【更新】提取主要版本和次要版本 (例如 11.4.0 -> 11.4)
          MAJOR_MINOR_VERSION=$(echo $FULL_GCC_VERSION | cut -d. -f1-2)
          GCC_VERSION_TAG="_gcc_v${MAJOR_MINOR_VERSION}" # 格式如 _gcc_v11.4
          
          # 2. 动态确定是否使用静态链接标志
          STATIC_FLAG=""
          if [ "${{ matrix.os }}" == "windows-latest" ]; then
            # 在 Windows (MinGW/g++) 上使用 -static 进行静态链接
            STATIC_FLAG="-static"
          fi
          
          # 3. 优化标志
          OPTIMIZATION_FLAGS="-O3 -s -flto"
          
          # 4. 动态生成最终输出文件名 (包含后缀和 GCC 版本标签)
          # 示例: main_linux_ubuntu-22.04_gcc_v11.4 或 main_windows_gcc_v14.1.exe
          OUTPUT_NAME="main${{ matrix.suffix }}${GCC_VERSION_TAG}${{ matrix.file_extension }}"
          
          echo "Compiling as: $OUTPUT_NAME using GCC v$MAJOR_MINOR_VERSION"
          
          # 5. 运行编译命令
          g++ -o "$OUTPUT_NAME" main.cpp person.cpp $OPTIMIZATION_FLAGS $STATIC_FLAG
          
          echo "EXECUTABLE_NAME=$OUTPUT_NAME" >> $GITHUB_OUTPUT # 将文件名保存为步骤输出

      # 步骤 3: 上传编译好的可执行文件作为Artifact (工件)
      # Artifact是工作流任务之间共享文件的方式
      - name: Upload compiled artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.compile_step.outputs.EXECUTABLE_NAME }} # 工件名称就是可执行文件名
          path: ${{ steps.compile_step.outputs.EXECUTABLE_NAME }} # 工件路径

  # ==================================
  # 任务 2: Release (发布)
  # ==================================
  release:
    name: Create GitHub Release and Upload Assets
    runs-on: ubuntu-latest
    needs: build # 依赖于 build 任务：必须等所有 Linux/Windows 编译都成功后才运行
    permissions:
      contents: write # 必须有写入权限才能创建 Release

    steps:
      # 步骤 1: 下载所有编译好的 Artifact (Linux和Windows的两个可执行文件)
      - name: Download all compiled artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts # 将文件下载到本地的 artifacts 文件夹中

      # 步骤 2: 创建 GitHub Release 并上传附件
      - name: Create Release and Upload Assets
        uses: softprops/action-gh-release@v1 # 使用一个常用的第三方Action来处理Release
        with:
          # 使用当前的 Tag 名称作为 Release 的名称
          name: Release ${{ github.ref_name }} 
          # FIX: 使用 '**/*' 递归模式来匹配所有子目录下的文件
          files: ./artifacts/**/*
          draft: false # 直接发布，不作为草稿
          prerelease: false